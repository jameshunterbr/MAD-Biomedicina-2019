---
title: "Matéria de Análise de Dados (MAD) - Biomedicina"
subtitle: "Análise de Dados com R"
author: "James R. Hunter"
date: "`r Sys.Date()`"
output:
  pagedown::html_paged:
    toc: true
    self_contained: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introdução

```{r MADlogo, echo = FALSE, fig.align='center', fig.height = 2, fig.width = 2, fig.cap = "Matéria de Análise de Dados"}
gr <- here::here("graficos")
knitr::include_graphics(glue::glue(gr, '/course_logo_3_small.png'))
```


Nos capítulos seguintes, nós vamos aprender a linguagem de estatística e programação R e sua utilização na análise de dados. O "approach" será bem prática. Vamos começar com a instalação do software necessário, continuar com operações básicas em R, e explorar vários metodos de análise para os estudos biomédicos. No longo do caminho à conclusão da matéria, você terá muitas oportunidades para praticar suas habilidades.

Deixe-me ressaltar aqui que estou escrevendo e desenvolvendo todos os materiais da matéria em R, no formato *R Markdown*: apostila, slides, etc. R com RStudio tem uma gama de recursos super abrangente. Nós vamos ver neste curso rápido só uma pequena porção deles.

Quando inclui programação em R, vou usar o seguinte fonte:

```
sub_dados <- dados %>% 
  select(dia20:dia25)
glimpse(sub_dados)
summary(sub_dados)
sub_dados %>% map_dbl(sd)
```

As vezes, vai ter um ponto importante que não cabe linearmente no texto. Este tipo de ponto eu chamo um **VSS**, um *verbum sapientibus satis* que é Latím para "uma palavra é suficiente para os sábios", em honra da minha professora de Latím de ensino médio, Profa. Walden.  

# Vamos Começar

O foco aqui é o que você precisa para instalar os softwares (*R* e *RStudio*) e tentar alguns exercícios básicos que vai facilitar nosso trabalho.

## Historia de R e Porque Precisamos Ele

### Historia

O antigo Bell Labs de ATT em Nova Jersey foi uma fonte rica das linguagens de computação. C e seus derivativos vêm de lá. S, uma linguagem que permitiu que cientistas do laboratório podem pôr estatística no contexto de computação sem precisar programar do início todas as funções necessárias para executar análises estatísticas como tinha sido necessário em Fortran ou Cobol ou Pascal. Quando o Bell Labs foi desmembrado ao final da década dos 1980s, S tornou um produto comercial (que ainda existe). 

Nos anos 1990s, Ross Ihaka e Robert Gentleman de Nova Zelândia criou um derivativo *open-source* da S, que eles chamaram "R", continuando a tradição de Bell Labs de dar às linguagens nomes de uma letra só. Ihaka e Gentleman disponibilizaram a R em 1999. Agora, estamos usando versão 3.6.1. R tem uma comunidade extremamente ativa. Desenvolvedores e usuários contribuíram com mais de 14.500 pacotes com funções e conjuntos de dados adicionais. Esses pacotes abrangem todas as áreas acadêmicas e profissionais em que possamos pensar, de análise de finanças quantitativas até astrofísica até microbiologia. R realmente tornou na última década uma das mais importantes linguagens de computação.

Nas faculdades em quase todo o mundo, R é a ferramenta de pesquisa mais popular hoje. E a presença dela nas empresas está crescendo diariamente. Especialmente em medicina e microbiologia, R tem recursos muitos importantes. Além dos pacotes das funções em R, existe pacotes do sistema Bioconductor que tratam de quase todas as análises importantes possíveis genômicas que precisamos usar para projetos em biologia e medicina.

Uma das razões que explica este crescimento forte da R é que ela fica *open-source*. Portanto, pode adquirir **de graça**, sim--livre de custo. **Custo zero** (para aqueles que não acreditaram a primeira vez). 

### Porque Professor Jim Usa R

Eu tenho uma longa história com programas como SPSS, Stata, SAS e mesmo Graphpad Prism. Comecei de usar SPSS quando ainda estava nos cartões IBM e os computadores eram os IBM 360s (aliás, os anos 60). Tudo bem. Usei várias versões de todos esses outros programas, mas sempre eu estava insatisfeito. Em 2012, descobri R e percebi que minhas insatisfações com SPSS, etc. tiveram solução. A vantagem grande de R sobre os outros programas é que você pode controlar absolutamente a sequência das operações (passos) em sua análise. Você escreve um programa num *script* (i.e., pequeno programa) e o R vai executar exatamente o que você o mandou fazer. E amanhã vai executar uma nova análise com exatamente o mesmo resultado que ontem.

### Problemas com os Tradicionais Programas da Análise de Dados

Com todas as caixas de diálogo e menus, os programas da análise de dados distanciam você dos detalhes e passos da análise e da limpeza dos dados. E mais, se você não clicar nas opções exatas na terça-feira da análise que você fez inicialmente na segunda-feira,  a análise produzirá um resultado diferente. Pior ainda, essas caixas oferecem muitas opções que você não entende (porque você é um administrador, biólogo, arquiteto, etc., mas não um estatístico) e como resultado, a análise não faz sentido e você não pode realmente explicar as conclusões.

Como disse Prof. Sacha Eskamp da Universidade de Amsterdã:

> *You can only do what the buttons say you can do.* [^1] [Você pode fazer somente o que os botões dizem que você pode fazer.]

[^1]: Baker, Monya, "Code Alert", **Nature**, Vol 541, 26/1/2017, p. 563 - 565. 

## Software: Open-Source vs. Comercial

Além disso, o custo desses programas é absurdamente caro. Mesmo nas edições para estudantes, o preço frequentemente fica acima do que os alunos podem pagar. Como efeito colateral, essa encoraja a proliferação das cópias não autorizadas. Onde fica a ética em ciência ou negócios quando alunos precisam começar a carreira roubando software? Faz muito tempo, softwares *open-source* eram de baixa qualidade. Mas, não mais. Existem equivalentes para os softwares pagos em quase todas as áreas em que precisamos programas. O mundo dos softwares *open-source* realmente mudou. Fora do Microsoft Word®, eu raramente uso softwares pagos. 

## R vs. Python

Uma alternativa para R com um conceito paralelo de programação das análises é a linguagem *Python*. Lançado em 1991 pelo holandês Guido van Rossum, Python tirou o nome do grupo comédico inglês "Monty Python's Flying Circus", não da espécie da serpente. Ela é uma linguagem de alto nível interpretada, exatamente como R. Mas, Python foi desenhada como uma linguagem geral em contraste a R, que tem sua origem em estatística. Para executar até estatística básica em Python, precisa também aprender a programação de vários módulos como Pandas, necessários para representação dos conjuntos de dados em Python.

R e Python estão tornando mais compatíveis. Nesta matéria, vocês aprenderão as duas idiomas juntas.

## Aprendizagem de R, É Difícil?

É bastante fácil aprender os elementos básicos de R, inclusive, especificar vetores e conjuntos de dados (que chamamos em R, *dataframes* ou *tibbles*), executar funções básicas de estatística e matemática. No primeiro fim de semana, nós vamos construir e executar várias simulações Monte Carlo, [^2] uma tarefa que precisa habilidade de construir e especificar dados e fazer uma análise. 

[^2]: Irizzary, Rafael, **Introduction to Data Science**, (https://rafalab.github.io/dsbook), Ch. 26.3.

Então, nas fases iniciais de aprender R, você não vai sofrer muito. Mais tarde, quando você quer utilizar pacotes e funções mais avançados (como os de Bioconductor), esses precisarão bastante foco e concentração para programar corretamente. Mas, nós deixaremos essa fase para a última aula do curso e os módulos seguintes.

Como as outras linguagens de programação, você escrever comandos numa forma que o programa entende, um depois do outro com uma sintaxe abreviada que segue as regras da função que você está executando. Por exemplo, se queremos achar a média de 100 números aleatórios entre 1 e 1000, podemos dizer o seguinte:

```
set.seed(1)
dados <- runif(100, min = 0, max = 1000)
media <- mean(dados)
```

Este exemplo funciona. (O resultado é 517.847.) Quando você instala R, pode executar os comandos. Mas, o ponto aqui é mostrar para vocês que o código precisa ser escrito exatamente como o programa demanda. Como vocês provavelmente já sabem, o computador é uma máquina de adição grande e estúpida (*"a computer is a big, dumb adding machine"*). Ele faz exatamente o que você comanda ele fazer.

## Advertência Importante

Vai ser imprescindível que vocês investem um pouco de tempo no curso antes das aulas presenciais. Primeiro, precisam instalar os softwares nos seus laptops para poder fazer as lições da casa. Segundo, precisa ler o material que sugerirei aqui. E, terceiro, talvez podem experimentar um curso de R básico no Internet, pelo menos tentar algumas lições para não ficar totalmente perdido na primeira aula.

## Instalação dos Softwares

### Instalação do R

Você pode achar R no site seguinte:

>  https://cran.r-project.org/

CRAN é o grupo oficial que mantem R e garanta que todos os componentes funcionam sozinhos e juntos. Esta é uma razão que R está tornando muito popular -- a qualidade do produto é muito alta. Figura 1 mostra a tela principal de R.


```{r Rinicial, echo = FALSE, fig.align='center', fig.cap = "R Tela Inicial"}
gr <- here::here("graficos")
knitr::include_graphics(glue::glue(gr, '/CRAN_361_initial_screen.png'))
```

Verifique que a versão é 3.6.1, com o codinome de "Action of the Toes". 
 
Existem versões para Windows, MacOS (o novo nome de OSX) e para vários sabores de Linux. Na parte superior da tela, clique no link que é apropriado para seu sistema operacional e seguir as instruções para download do software. Vou detalhar aqui alguns dos passos para Windows e para MacOS.

### Instalação de R para os Windows

1. Clique no link "Download R for Windows"

2. Na próxima tela, clique no link "base" como na figura seguinte.

```{r Rwin1, echo = FALSE, fig.align='center', fig.cap = "R Tela Windows"}
knitr::include_graphics(glue::glue(gr, '/CRAN_win_screen_1.png'))
```

3. Clique no link: "Download R 3.6.1 for Windows"

O site vai fazer o download do programa como é normal para os downloads. Você pode instalar o programa seguindo seu procedimento normal e R vai depositar no Desktop um ícone.

### Instalação do RStudio

Primeiro, porque precisamos este programa? RStudio dá asas para R. Ao nível mais básico, RStudio é nossa interface para R. É um programa baseado num editor de texto onde você escreve os scripts que vai desenvolver para R. Mas, é realmente o canivete suíço de R. Lá pode gerenciar os arquivos, estabelecer projetos que colocam todos os arquivos de um projeto junto, fazer controle de versões, e ver seus resultados, relatórios, etc. Em todas nossas aulas, vou usar RStudio para controlar todas as demonstrações de programação, e RStudio é o software em que fiz toda a documentação da matéria.  RStudio também é de graça. Existe uma versão comercial, mas vocês não precisam ela.

Para instalar, navegue diretamente á página https://www.rstudio.com/products/rstudio/download/, que permite que você evita muita informação desnecessária. 

Esta tela tem muita informação. Então precisa rolar para baixo até que você chega nos "Installers for Supported Platforms". Parece como a figura seguinte:

```{r Rstud_install, echo = FALSE, fig.align='center', fig.cap = "RStudio Tela Instalação"}
knitr::include_graphics(glue::glue(gr, '/RStudio_download.png'))
```


Agora, pode fazer o download para o sistema operacional seu e instalar o programa seguindo as instruções no módulo de instalação. (O número da versão provavelmente seria diferente do aquele na figura.)

Se vocês precisam ajuda adicional com a instalação, coloquei um vídeo no meu canal de YouTube chamado "MAD CD Instalar R". Para alcançar o canal, vá para: https://www.youtube.com/channel/UCbvgZ8RYeTtgjhAKE-jub5A

## Iniciando RStudio

No seu Desktop ou nos menus, clique no ícone de RStudio (não o ícone de R) duas vezes. RStudio vai abrir e R vai abrir automaticamente dentro de RStudio. Num dos painéis (normalmente o painel no lado esquerdo) vai aparecer o *Console*, onde R executa as funções. No lado direto têm dois painéis. Naquele para cima são várias abas relacionadas aos variáveis que R guarda na memória ativa do computador e comandos que você executa. No painel inferior, têm abas que mostram informação sobre os arquivos na pasta "*working directory*", o lugar onde R acha os arquivos (data, programas) que você quer executar, os pacotes que você tem no computador e as páginas de assistência ("*Help*") para R. Vou falar sobre todos esse tópicos mais tarde. Utilizando as Preferências (no item de menu de "RStudio"), você pode controlar a aparência da tela). 

O painel de Console mostrará que a versão atual (3.6.1) de R está carregado e pronta para operação.

```{r Rstud_main, echo = FALSE, fig.align='center', fig.cap = "RStudio Tela Inicial"}
knitr::include_graphics(glue::glue(gr, '/start_up_text.png'))
```


## Instalar os Pacotes Necessários

Durante o curso, nós vamos usar vários pacotes com funções adicionais que vão além as de R básico ("*Base R*"). Vocês podem instalar os mais importantes através de um script que já preparei para você. Trabalhando com o script vai permitir que vocês começam de aprender como usar o R. O script tem o nome "instalar_pacotes.R". 

O seguinte é o texto do arquivo. É muito simples. Só 2 comandos. Um que especifica os pacotes que vamos instalar e uma função que faz o trabalho (`install.packages()`). 

```{r inst_packs, eval = FALSE, echo = TRUE}
pacotes <- c("tidyverse", "broom", "car", 
             "caret", "corrr", "data.table", "DataExplorer",
             "descr", "devtools", "gapminder", 
             "ggpubr", "ggvis", "glue",
             "gmodels", "here", "Hmisc", 
             "hms", "jsonlite", "kableExtra", 
             "knitr", "lattice", "librarian", 
             "lubridate", "magrittr", "mice", 
             "nortest", "nycflights13", "outliers", 
             "pROC", "psych", "RColorBrewer", 
             "Rcpp", "readxl", "ROCR", 
             "shiny", "styler", "usethis", "titanic")

install.packages(pacotes)
```

### Nosso Primeiro Programa

O primeiro comando, especificando os pacotes para carregar, usei 2 comandos importantes para R. Eu quero usar o nome `pacotes` para referir à lista dos 37 pacotes. Não quero teclar eles cada vez preciso usar. Chato. Então, estou *atribuindo* a palavra `pacotes` para ficar no lugar da lista inteira. Faço isso com o simbolo de uma seta pontado para a esquerda "`<-`", composto do caráter "`<`" e o hífen "`-`". Este é chamada o operador *assignment* e não é equivalente ao sinal de "`==`", que é uma condição lógica (uma coisa sendo igual a uma outra). Entretanto, R quer ser tão amigável que permite que você usa o sinal "=" para atruibição. 

Uma dica sobre o operador de atruibição. Só usa o "`<-`" e não o "`=`". Em algum momento, você vai confundir os 2 usos de "`=`". Todos nós fazemos. Desenvolve o hábito agora de usar o "`<-`" e pode evitar esse erro. 

O segundo comando nesta expressão é o `c()`. Este função quer dizer "concatenar" ou colocar os itens que seguem num vetor. Os itens podem ser qualquer tipo de dado que R reconhece. No capítulo X, exploraremos os tipos de dados que pode usar em R. Outra novidade é que agora você viu um **vetor**. Um vetor é um matriz, mas de uma dimensão só. Depois que você executa esta função, vai ver na janela de *Environment* a variável `pacotes` e que ela é do tipo "caráter" (`chr`) e tem elementos 1 até 37.

```{r pacotes1, echo = FALSE, fig.align='center', fig.cap = "Vetor Pacotes"}
knitr::include_graphics(glue::glue(gr, '/pacotes_vector.png'))
```

Na função `install.packages(pacotes)`, R vai inserir o conteúdo do vetor `pacotes` no lugar da palavra e assim executar.

### Localização do Arquivo `instalar_pacotes.R`

Um dos recursos mais importantes para todos os programadores de computador é GitHub. É a face pública do sistema de controle de versões `git`. Git permite que você sempre tem todas as versões de seus programas ou scripts mantidas no seu computador (numa forma eficiente) para que você possa voltar às versões anteriores quando você está explorando e corrigindo erros que todo programador faz. GitHub tem *repositórios* onde são guardados os arquivos de um projeto. Nós vamos falar dos projetos um pouco mais tarde. 

Nosso curso tem um *repo* (como pessoas referem aos repositórios) que você pode achar aqui: https://github.com/jameshunterbr/MAD-Biomedicina-2019

```{r github1, echo = FALSE, fig.align='center', fig.cap = "GitHub Repo"}
knitr::include_graphics(glue::glue(gr, '/github_repo_biomed.png'))
```

Se você clica no nome de arquivo, você irá à tela seguinte, onde fica o código dos dois comandos. 

```{r github2, echo = FALSE, fig.align='center', fig.cap = "Instalar_Pacotes.R no GitHub"}
knitr::include_graphics(glue::glue(gr, '/instal_pac_file.png'))
```

Aqui, clicar no botão **Raw** e fazer um "right-click" (botão secondário do mouse) na tela seguinte. Você pode salvar o arquivo para seu *working directory* usando o botão **Save Page As ...**. Esta tela mostra o comando no Firefox e os comandos de seu browser talvez são um pouco diferentes. 
```{r github3, echo = FALSE, fig.align='center', fig.cap = "Save File As ..."}
knitr::include_graphics(glue::glue(gr, '/save_page_as.png'))
```

### O Que É Um *Working Directory*?

O *Working Directory* ("pasta de trabalho") é o lugar onde R espera achar todos os arquivos que vai precisar (dados e scripts). Você pode achar ele em RStudio clicando o itém do *toolbar* da aba *Files* chamado *More/Go To Working Directory* e RStudio vai levar você lá. Se o *Working Directory* não é a pasta que você esperou, pode navegar na lista dos arquivos para a pasta que quer usar como o *Working Directory*. Nós vamos ver uma alternativa para esta estratégia quando apresento projetos.

### Instalar os Pacotes

O próximo passo é carregar o programa com os comandos e executá-lo. Para carregar, só precisa clicar no nome do arquivo `instalar_pacotes.R` e ele vai abrir numa janela acima do Console.

```{r janela_script, echo = FALSE, fig.align='center', fig.cap = "RStudio Janela de Programas"}
knitr::include_graphics(glue::glue(gr, '/instalar_pacotes_280719.png'))
```

Para executar o programa, você pode clicar na palavra *Source* na barra acima do programa. Vai precisar um pouco de tempo, mas vai carregar no seu computador esses pacotes e outros em que eles dependem para funcionar.

## Prontos para Trabalhar

Fizemos a instalação dos softwares e a maioria dos pacotes que vamos usar durante o curso. Finalmente é a hora de usar R, que vamos fazer no próximo capítulo. Mas primeiro vamos relembrar os pontos importantes deste processo inicial:

  1.  Fizemos o download do web da R e da RStudio e instalamos os programas
  2.  Aprendemos o que é o *Working Directory*
  3.  Aprendemos o que é o operador de atruibição (`<-`)
  4.  Aprendemos o que é um vetor
  5.  Aprendemos a função `c()`
  6.  Aprendemos que o comando para instalar pacotes é `install.package()`
  7.  Temos o repo no GitHub: https://github.com/jameshunterbr/MAD-Biomedicina-2019
  8.  Pode consultar o canal no YouTube:  https://www.youtube.com/channel/UCbvgZ8RYeTtgjhAKE-jub5A


# Recursos para o Curso

Agora que instalamos os softwares mas antes de começar análises com R, aqui são recursos que você pode usar para acelerar sua aprendizagem de R. Já mencionei alguns como o canal YouTube, mas aqui é uma lista sistematizada que você pode consultar para achar ajuda no desenvolvimento das suas habilidades em R.

## Cursos

**HarvardX** (parte do sistema dos cursos à distancia **edX**) oferece uma série dos cursos sobre o uso de R na Ciência dos Dados, PH125. Os primeiros dois cursos neste série: [Data Science: R Basics] (https://www.edx.org/course/data-science-r-basics) e [Data Science: Visualization] (https://www.edx.org/course/data-science-visualization-harvardx-ph125-2x). O professor dos dois é Rafael Irizzary, Chefe de Departamento de Bioestatística do Hospital Dana-Farber de Câncer em Boston e do Escola Chan de Saúde Pública da Universidade Harvard. Você pode fazer cursos de edX de graça em modo de "auditar", que quer dizer que você não recebe certificado se você completa o curso.

Também da Harvard, mas esta vez diretamente da **Escola Chan de Saúde Pública**, tem https://hbctraining.github.io/Intro-to-R/schedules/2_day.html, que tem todas as matérias de um curso de 2 dias sobre R e o Tidyverse. Parece para mim de ser de qualidade alta.

**Johns Hopkins** no **Coursera** tem várias series de cursos muitas boas que abrange (como os de Harvard) R e R aplicada aos estudos biológicos. Roger Peng, Steven Salsburg, Jeff Leek, Brian Caffo e os demais professores têm boa didatica e expliquem bem o uso de R em estudos estatísticos. Pode começar com o curso seguinte para focar nas habilidades básicas de programação em R: https://www.coursera.org/learn/r-programming. 

**Utrecht University** em Holanda tem um curso introdutório, também excelente que ensina os conceitos básicos de R: https://github.com/UtrechtUniversity/workshop-introduction-to-R-and-data. Os slides do curso foram traduzidos à português por Dr. Diego Mazzotti da UNIFESP e agora da Universidade de Pennsylvania. Os slides deles são em nosso repo de Github com a permissão dele e vai reconhecer as porções que dos slides que eu emprestei com a permissão do Dr. Mazzotti e da Utrecht.

**Duke University** no **Coursera** também tem uma sequência dos cursos liderada por Profa. Mine Cetinkaya-Rundel (agora da Universidade de Edinburgh, Escocia) que é um dos melhores professores de R que vi nos cursos virtuais. Pode começar aqui: https://www.coursera.org/learn/probability-intro?specialization=statistics

## Livros --- R & Programação

Os livros seguintes são alguns entre meus preferidos. Tenho foco aqui só em livros que são de graça. Não pode sempre fazer um download de um livro -- só está disponível no internet -- todos valem muito a pena.

  - Irizzary, **Introduction to Data Science** (https://rafalab.github.io/dsbook; texto para cursos de HarvardX)
  - Ismay & Kim, **Statistical Inference via Data Science: A moderndive into R and the tidyverse** (https://moderndive.com/)
  - Navarro, **Learning statistics with R: A tutorial for psychology students and other beginners** (https://learningstatisticswithr.com/book/)
  - Peng, **R Programming for Data Science** (Leanpub & Bookdown)
  - Peng, Kross & Anderson, **Mastering Software Development in R** (Leanpub & Bookdown)
  - Tierney, **R Markdown for Scientists** (https://rmd4sci.njtierney.com/)
  - Wickham & Grolemund, **R for Data Science** (http://r4ds.had.co.nz ou O'Reilly)

Se você quer escolher só um, sugiro **R for Data Science** pelo inventor do Tidyverse que pode ler de graça na Internet. Se for dois, o segundo seria ou **Statistical Inference via Data Science: A moderndive into R and the tidyverse** ou **R Programming for Data Science** ou **Learning Statistics with R**. 

Todos os livros de Bookdown pode ser achados (de graça): https://bookdown.org/. Os livros de Leanpub você pode geralmente fazer um download de graça. 

## *Cheatsheets*

RStudio publica uma série de "*cheatsheets*", resumos dos comandos e funções de vários aspectos de programação com R. São excelentes e você deve guardar eles onde pode consultar eles rapidamente. Colocando todos os elementos das funções no lugar certo na ordem certa não é fácil. *Cheatsheets* tiram muito do sofrimento. Pode achar eles aqui: https://www.rstudio.com/resources/cheatsheets/

## Sites

Existem muito sites e blogs além de CRAN e RStudio (que apresentei no último capitulo) que são focados em R. Aqui vou listar só poucos que podem ajudar você resolver duvidas sobre comandos e funções de R. Não hesite de usar eles. Em geral, são muito bons e tem respostas às suas perguntas.

  - **R Bloggers** (https://www.r-bloggers.com/) um compêndio de 750 blogs sobre R; destila os melhores posts desses blogs. Tem coisas interessantes quase todos os dias.
  - **Tidyverse** (https://www.tidyverse.org/learn/) tem muito informação sobre R e os programas do Tidyverse. É a fonte mais perto aos autores dos programas de *tidyverse*
  - **MAD-Stat** (https://madstatbr.wordpress.com/) o blog meu sobre R, estatística e bioestatística
  - **Stack Overflow** (https://stackoverflow.com/questions/tagged/r) um centro de esperteza em R e outros assuntos. Pode fazer perguntas depois que você escaneia se alguém respondeu para a mesma pergunta anterior. Se você quer postar no site, siga as recomendações sobre qual informação precisa dar para alguém responder. Os "experts" aqui não têm muito paciência infelizmente. Entretanto, este é o lugar onde vai achar respostas valiosas e vale a pena procurar uma solução aqui.
  
## Canal de Vídeo

Como eu disse no último capitulo, coloco vídeos nesse canal para ajudar você com questões que não são suficientemente explicadas em outros recursos. Se você tem uma duvida sobre um ponto, pode pedir que eu faça um vídeo sobre ele e vou postar. Para lembrar, o canal fica aqui: https://www.youtube.com/channel/UCbvgZ8RYeTtgjhAKE-jub5A

## Sistema de Ajuda de R e RStudio

O sistema de ajuda de R é muito completo. Toda função tem uma tela de ajuda. Uma das abas no RStudio (na janela a direta para baixo) é "*Help*" e você rapidamente ficará acostumado a consultar para achar a gramatica correta de usar nas funções. Mas, lembre que a documentação foi escrito por programadores, não romancistas ou jornalistas. Talvez pode ser difícil de entender as vezes. 

Começa com suas duvidas no sistema de *Help*, mas procure outros fontes de help se você não entende o texto lá facilmente. 

Se você tem uma pergunta e não acha uma solução facilmente ou recebe um mensagem de erro incompreensível, não hesite de copiar e colar a duvida ou mensagem em Google. Quase todas as duvidas que você pode ter já foram perguntadas por outros iniciantes de R e Google vai mandar você ver soluções uteis em Stack Overflow, R Bloggers e muito outros sites.

## Um Pensamento Final --- Perguntas

Pergunte bastante. Você não aprenda sem ter duvidas e perguntar para outros para ajudar resolver elas. Lembre que se você tem uma duvida, provavelmente outros tem a mesma duvida. Você não é só ajudando si mesmo; você está ajudando o grupo inteiro. **Não existem perguntas burras.** Como disse Carl Sagan (o astrofisico famoso que chefiou a versão original do programa de televisão "Cosmos": [^3]
  
>There are naive questions, tedious questions, ill-phrased questions, questions put after inadequate self-criticism. But every question is a cry to understand the world. **There is no such thing as a dumb question.** 

[^3]: Carl Sagan, **The Demon-Haunted World: Science as a Candle in the Dark**, p. 303.

# Tipos de Variáveis Comuns

Estamos prontos agora para pôr R em operação. Vamos iniciar com alguns exercícios e terminar esta capitulo com a manipulação e análise exploratório de um dataset interessante. Seria um boa prática para você replicar estes exemplos no seu R.

## O Que São Dados?

Parece que esta deve ser uma pergunta simples. Mas, vamos a esclarecer no contexto dos dados em R. No primeiro capitulo expliquei o conceito de atruibição e mostrei o simbolo `<-` que usamos invés de sinal de igualdade (`=`) para associar um nome com alguns valores. Esses valores podem ser numéricos ou texto, podem ser até listas ou matrizes. Mas, sempre usamos a convenção 

> nome do objeto **<-** definição do objeto 

onde a definição é os valores são o conteúdo do objeto.

## Exemplos de *Assignment*

```{r assign1}
x <- 5
x
class(x)
```

Aqui a letra `x` vai assumir o valor 5. Ou seja, `x` vai ser definido por 5. Podemos colocar na tela simplesmente colocando o nome do objeto. Este objeto nós podemos também chamar uma *variável*. Utilizando a função `class()`, nós podemos ver que esta variável é do tipo ou classe *numeric*. Variáveis da classe *numeric* também podem ter valores decimais como `5.5`. 

Existe um outro tipo importante de classe das variáveis númericas: números inteiros. Números inteiros são representados dentro do computador por menos bytes por número mas não têm diferenças em operação importantes. Um número inteiro está marcado em R com o sufixo `L`. Porque L e não outra letra? Quem quer especular? Aqui é um exemplo.

```{r integer_assign}
var_integer <- 5L
var_integer
class(var_integer)
```

Se você não inclui o "L" como sufixo, R vai interpretar o número como `numeric`.

Podemos definir nossa variável númerica `x` também através de uma operação aritmética:

```{r assign2}
x <- 3 + 2
x
```

Também, nós podemos usar funções para definir o valor de `x`. Aqui usei o raiz quadrado. Mas, têm muitas outras funções que você pode utilizar. 

```{r assign4}
x <- sqrt(675.3)
x
```

Agora, deixamos usar um teste lógico para definir o valor de uma variável.

```{r assign3}
var_logical <- 1 == 0
var_logical
class(var_logical)
```

Esta vez, demos a `var_logical` o valor que é um valor lógico: 1 não igual a 0, então o resultado deve ser `FALSE`. Valores lógicos só podem assumir os valores `TRUE` ou `FALSE`.

Finalmente, entre os tipos de variáveis mais comuns, temos texto, chamado aqui *character*.

```{r char_var_def}
text_var <- "Hello, world!"
text_var
class(text_var)
```

Qualquer caráteres entre aspas (seja simples ou dupla, como aqui) vai ser visto como texto e ter a classe `character`. Existem funções e pacotes especializados que trabalham com essa classe de variável que aprenderemos mais tarde.

A definição de uma variável pode ser um pouco mais complicado ainda. Vamos fazer um cálculo usando nossos dados do primeiro capitulo. Aqui é o código (no formato levemente alterado):

```{r code_ex1}
set.seed(1)
dados <- runif(100, min = 0, max = 1000)
m <- sum(dados)/length(dados)
m
```

Aqui, temos três linhas que fazem operações e a quarta que relata o resultado. Vamos olhar em cada uma e ver o que faz.

`set.seed(1)`: `set.seed()` é um comando que fornece às funções que calculam valores aleatórios a instrução de sempre iniciar o cálculo no mesmo posição. Pode aceitar qualquer número inteiro como argumento. Aqui usei `1`. Mas, podia ter usado `43` ou `2019`. Qualquer número inteiro que você usa produzirá uma série de números aleatórios diferentes.

`dados <- runif(100, min = 0, max = 1000)`: dados é uma variável receberá 100 valores aleatórios entre 0 e 1000 (`min` e `max`). Estes valores são baseados na distribuição de números "uniforme", que quer dizer que todos os números entre os 2 limites têm uma chance igual de ser selecionados. O resultado `dados` vai ser um vetor com os 100 números.

`m <- sum(dados)/length(dados)`: para calcular `m`, nós vamos somar os 100 valores e dividir (`/`) o resultado pelo número de valores na variável (neste caso 100). Este é a mesma coisa que pedir a média de uma série de números, utilizando o cálculo que você vai lembrar de seu curso de estatística:

$$\mu = \frac{\sum_{i=1}^{n}x_{i}}{n}$$ 

>Você se lembrou desta formula, não?

Também, podemos usar a função `mean(dados)` para conseguir o mesmo resultado.

`m`: finalmente, indicando o nome da variável que cuja valor vai ser colocado na tela.

Se você quer explorar mais esses conceitos e as funções especificas, posso recommendar que você guarda o *cheatsheet* **Base R** aberta numa tela para consultas. Lembre que pode fazer um download do site de RStudio (https://www.rstudio.com/resources/cheatsheets/). É o segundo cheatsheet na lista dos "Contributed Cheatsheets".

```{r base_cheat, echo = FALSE, fig.align='center', fig.cap = "Base R Cheatsheet"}
gr <- here::here("graficos")
knitr::include_graphics(glue::glue(gr, '/base_r_cheat_screen.png'))
```

## Projetos e Pastas

Antes de continuar a consideração dos dados, variáveis e demais, vamos considerar projetos em R, algo que vai facilitar nossa vida de pesquisa bastante.

# Projetos e Pastas

Quando iniciando um novo projeto de pesquisa, temos as boas intenções de organizar todos nossos arquivos para não sofrer mais tarde (como amanhã!) quando voltamos para nossos dados. Nestes dias de hoje da ênfase em replicabilidade em ciência, organização dos projetos fica ainda mais importante. Cada artigo, estudo, poster, boa ideia, ele precisa seu próprio espaço no seu computador para não ser confuso com outros projetos. Geralmente, cientistas aceitam essa ideia.

Colocar ele em prática é outra coisa. Por isso, precisamos pensar um pouco em nosso fluxo de trabalho (*workflow*). Recebemos arquivos dos sequenciadores, das outras maquinas, dos arquivos que criamos com dados determinados de mão, dados que vem dos arquivos oficiais (e.g., demográficos), e de vários outros fontes. Temos uma pasta chamada `MEU_PROJETO` no algum nível do seu disco rígido. Pense bem: o que você vai fazer com todos os arquivos que ficarão dentro desta pasta. Tem uma organização deles ou são jogadas em um grupo. Eu sei que um projeto do tamanho médio pode ter até 500 arquivos. Vai lembrar onde todos são e o que quer dizer os nomes de todos daqui três meses. 

Organização de um projeto é uma tarefa que precisa um pouco de pensamento. Outro fator para lembrar. Numa época em que dividimos a responsabilidade para as pesquisas com vários colegas, temos que fazer possível que nossos programas/scripts funcionam para todos os membros da equipe.

Falamos mais cedo das *working directories*, as pastas ativas. A pasta ativa fica no final de cadeia das pastas que iniciam com a pasta *root* ou raiz. Você pode estabelecer que a pasta ativa é qualquer pasta que você quer com o comando `setwd()`. Por exemplo, eu posso trabalhar na pasta deste curso com o comando seguinte:

```{r wd, eval = FALSE, message = FALSE}
setwd("/Users/jameshunter/Documents/MAD/MAD-Biomedicina-2019")
```

Mas, este cria um grande problema. Ninguém fora de mim em nosso grupo tem essa pasta no seu computador. Aposto que eu seja o único com um usador com o nome de "jameshunter". Para qualquer outro computador ou cópia deste arquivo, o comando vai retornar um erro. A solução primitiva para essa problema é de copiar e colar a pasta certa em todos os lugares onde este aparece nos programas. Hiper-chato! 

## Projetos em RStudio

RStudio oferece um sistema para você tratar de todos seus projetos diferentes com nomes e espaços distintos. É um dos aspetos mais poderosos de RStudio. Um projeto de RStudio guarda todos os arquivos de um projeto juntos mas separados de todos os outros arquivos de seu computador numa pasta designado para o projeto em que você está trabalhando. Quando você estabelece um novo projeto ou trocar de um para um outro, RStudio inicia uma nova instância do programa para este projeto sempre seja independente dos outros. Você pode ter múltiplas projetos abertos no mesmo tempo apesar se seu computador tem memoria limitada (< 4GB) é provavelmente não uma boa ideia de ter mais que um projeto rodando simultaneamente.

Um dos pontos mais importantes sobre projetos é que RStudio vai usar a pasta onde você cria o projeto como a pasta ativa que fará muito para aliviar as ansiedades que vêm dos conflitos de pastas. Alguns professores acham que este ponto é tão importante que uma delas (Profa. Jenny Bryan da Universidade de British Columbia e de RStudio), uma autoridade sobre uso de R, disse numa presentação

> If the first line of your R script is

> `setwd("C:\Users\jenny\path\that\only\I\have")`

> I will come into your office and SET YOUR COMPUTER ON FIRE 

Como resultado, se você não quer que Profa. Bryan voa de Vancouver para São Paulo para ela incendiar seu computador, é melhor usar a habilidade de RStudio de criar projetos para seus trabalhos. 

**VSS--Sempre crie um novo RStudio projeto para cada projeto**

## Criar Um Novo Projeto

Na direta da tela acima das abas de "Environment, History, ...", você vai ver um logotipo de R com o texto "Project:(None)" mais uma seta que pode clicar. 

```{r proj_1, echo = FALSE, fig.align='center', fig.cap = ""}
gr <- here::here("graficos")
knitr::include_graphics(glue::glue(gr, '/tela_inicial_proj.png'))
```

Esse texto indica que ainda não tem um projeto ativo. Podemos iniciar a criação de um projeto clicando nessa seta. No menu drop-down, podemos ver a opção de criar um novo projeto (*New Project*) ou selecionar um dos projetos com que você já tinha trabalhado. 

```{r proj_2, echo = FALSE, fig.align='center', fig.cap = "Project Menu"}
knitr::include_graphics(glue::glue(gr, '/proj_drop_down_menu.png'))
```

Queremos selecionar *New Project*, que abrirá a janela que permite que você selecionar onde quer localizar o projeto no seu disco. Você pode escolher de criar uma nova pasta (*directory*) para seu projeto ou colocar ele em uma pasta existente. Se você já tem um espaço no seu computador para seu projeto atual, pode escolher ele com essa segunda opção. 

```{r proj_3, echo = FALSE, fig.align='center', fig.cap = "Create Project"}
knitr::include_graphics(glue::glue(gr, '/create_project_1.png'))
```

Mas, neste caso, vamos criar uma nova pasta. Então, clique na área de *New Directory* e a janela seguinte aparecerá. Existem vários tipos de projetos que pode fazer em RStudio. Mas, vamos selecionar o primeiro, o projeto basicão, *New Project*.

```{r proj_4, echo = FALSE, fig.align='center', fig.cap = "Tipo de Projeto"}
knitr::include_graphics(glue::glue(gr, '/create_2_type_proj.png'))
```

Essa escolha levará você para a tela seguinte em que você pode dar um nome para a pasta que conterá o projeto.

```{r proj_5, echo = FALSE, fig.align='center', fig.cap = "Projeto Novo Nome"}
knitr::include_graphics(glue::glue(gr, '/proj_directory.png'))
```

Aqui, dei o nome "test_proj" ao novo projeto. Quando você clique no botão `Create Project`, o sistema criará uma pasta com este nome. Você pode ver que este pasta vai ficar como uma sub-pasta da pasta `~/Documents/MAD` que é apropriado para meu computador. Você pode colocar ela num local conveniente para você. O til `~` ao início da sub-pasta quer dizer a pasta raiz do computador, como "C:\" em Windows. Pode ver aqui também dois caixas para selecionar controle de versão *git* ou *packrat*. Por enquanto, deixa-elas vazias. São capacidades de R e RStudio mais avançadas. Para finalizar a criação do projeto, clique no botão `Create Project`.

```{r proj_6, echo = FALSE, fig.align='center', fig.cap = "Novo Projeto Completo"}
knitr::include_graphics(glue::glue(gr, '/proj_created.png'))
```

Agora, no parte da cima a direta, você vê a indicação que você está trabalhando com o projeto `test_proj`. Também, na margem do Console, pode ver o nome da pasta ativa. Também fica em azul a cima da lista dos arquivos. Finalmente, RStudio criou um arquivo `test_proj.Rproj` que guarda as informações para avisar o programa como abrir este projeto no futuro.

### SubPastas

Por costume e para ajudar na organização do projeto que pode durar meses ou anos, crio também subpastas para conter documentos de tipos diferentes, como scripts, textos, gráficos, etc. A estrutura que geralmente uso para projetos de pesquisa é o seguinte:

- projeto
  - data_munge
  - data_raw
  - docs
  - graficos
  - outros
  - scripts_analise
  - scripts_limpar
  - scripts_misc
  - slides
  
#### Algumas Notas sobre as SubPastas

1. Separar os dados. Deixa os dados originais que você importou dos sequenciadores, outras maquinas ou mesmo das planilhas de Excel na pasta `data_raw`. 

**VSS** Esses arquivos são os originais. Se você muda eles, eles seriam corruptos. 

Salve versões que você modifica na pasta `data_munge`. Fazer toda a limpeza, restruturação, etc. nessas versões ali, não nos originais. Se você esquecem essa regra, não seria Jenny Bryan que vem incendiar seu computador. Eu ou seu orientador faria! (Piada, mas piada séria!)

2. Divido scripts (programas) baseado em tipos. Os que uso para limpar dados, frequentemente uso versões semelhantes em vários projetos. Então, é simplesmente uma conveniência, mas separo eles dos outros que são mais particular para projeto individual. Também, gosto de saber onde são os slides  e os documentos que criei (ou em RMarkdown ou em PowerPoint). 

Lembre que um projeto importante (tese ou dissertação, por exemplo), pode ter um número grande de arquivos (centenas ou milhares). Criar uma estrutura para guardar eles ajudará sua sanidade quando o dia de apresentação do trabalho aproxima.

## Onde Estamos, Professor? "*We're HERE*"

Criar um projeto é o primeiro passo para evitar a bagunça que resulta de ter vários projetos com várias pastas e vários colegas trabalhando nos seus próprios computadores. Por exemplo, meu *file path* da raiz para pasta de projeto no meu Mac Air pode ser:

- "/Users/jameshunter/Documents/MAD/test_proj"

Mas, o *file path* para meu colega Marcelo pode ter o texto no seu computador de Windows pode ser:

- "c:\Users\Marcelo\Documents\BioMedicina\Projetos\test_proj"

Muito diferente. Se eu tinha colocado uma referência à subpasta que contem todo meu *file path* numa linha de código, não funcionará no computador de Marcelo. Precisamos usar uma segunda função da R para evitar esse problema.

Um dos pacotes que você tem na sua instalação de R agora é chamada `here`. Este faz uma coisa importante, mas faz ele com elegância. Ele avisa o que é o *file path* inteiro para chegar a pasta ativa (*working directory*).

Por exemplo, podemos ver a pasta ativa deste documento e toda a cadeia que liga ele ao raiz com a função `here()`. 

```{r pasta_ativa}
here::here()
```

Para mostrar os gráficos neste capitulo e outros, eu guardo todos os arquivos de gráfico numa subpasta de `MAD-Biomedicina-2019` chamado gráficos. Para mostrar nesses capítulos os gráficos, eu posso usar o comando primeiro para especificar onde o sistema pode achar o subpasta `graficos`. 

```{r} 
gr <- here::here("graficos")
gr
```

Agora, posso usar a variável `gr` em qualquer computador para apontar para subpasta `graficos` porque `here()` mostrará a subpasta `graficos` para aquele computador. A sequência de dois dois-pontos no comando separando o pacote `here` do comando `here` é a maneira de usar uma função de um pacote sem precisar carregar todo o pacote com `library()` ou `librarian::shelf()`.

# Estilo de Código e Manipulação das Variáveis
## Questões de Estilo

Como você apresenta o código vai facilitar o seu entendimento do que você fez tanto quanto ajudar uma outra pessoa entendê-lo. Vale a pena seguir umas regras consistentes. Assim, tudo mundo (e R) vai entender o código que você escreveu. Vamos fazer um exemplo para mostrar este ponto.

```{r peso, echo = TRUE}
## 1ª Versão
peso <- 55  ## Pessoa pesa 55 kg.

## 2ª Versão
peso_kg <- 55 ## Mais claro

## Pode Converter à Libra
peso_lb <- peso_kg * 2.2
peso_lb

```

O primeiro ponto a ressaltar é que este código tem muitos comentários. Fazemos comentários em R utilizando o sinal `#` ("hashtag"). R não interpreta qualquer caráter depois do primeiro `#` numa linha de código. Este pode ocorrer numa linha sozinha como `## 1ª Versão` ou depois de um operação como na segunda linha (`peso <- 55 ## Pessoa pesa 55 kg.`).

A primeira versão da atribuição não é muito clara. Se não tivesse o comentário sobre `55 kg`, como você saberia que estávamos falando de conversão entre quilos, libras ou toneladas? A segunda versão esclarece diretamente no nome da variável `peso_kg`. E a linha que faz a conversão também tem uma variável com um bom nome que explica claramente o que é este valor.

Frequentemente, pessoas gostam de usar nomes muito breves, mas não muito claros com `x`, `i` ou `n24`. É muito melhor usar nomes que explicam o que contem a variável que de enfatizar brevidade.

Existem muitos outros aspetos de estilo que são padronizado no mundo de programação de R. Uma guia para um estilo claro de programação foi desenvolvido pelo Hadley Wickham de RStudio e pode ser achado aqui: http://style.tidyverse.org/. O pacote `styler` que você carregou na instalação criou "Addins" no RStudio que pode acessar do item na barra superior. Esses opções permite que R em si coloca seu código no estilo correto seguindo as normas da guia de Wickham.

```{r styler, echo = FALSE, fig.align='center', fig.cap = "Styler Addins"}
gr <- here::here("graficos")
knitr::include_graphics(glue::glue(gr, '/style_addin.png'))
```

### Uma Pergunta sobre o Estilo -- Parenteses depois de uma função

Este é um bom momento para comentar porque sempre usamos `()` depois do nome da função. Com os parênteses, R vai executar a função. Sem eles, vai imprimir para a tela o código (ou seja, o conteúdo) da função. Por exemplo, na figura seguinte, mostro a função `coalesce` do pacote `dplyr`. Na primeira versão, **sem** parenteses, R mostra o código da função. Na segunda, **com** parenteses, R mostra o resultado do cálculo da função.

```{r getwd, echo = FALSE, fig.align='center', fig.cap = "coalesce vs. coalesce()"}
knitr::include_graphics(glue::glue(gr, '/coalesce()_vs_coalesce.png'))
```

## Conjunto dos Dados Mais Complicado

Este exercício, que estou adaptando do currículo do grupo "Software Carpentry", [^4] analisa  dados médicos sobre tratamentos para a artrite e a inflamação que a doença causa. Ele mostra a avaliação de inflamação de 60 pacientes diariamente durante 40 dias. 

Para nossos fins de aprender R, podemos aprender 

- Como inserir dados nos objetos R
- Como manipular esses dados
- Gráficos básicos
- Resumos descritivos de dados
- Funções em R
- Loops

[^4]: Agradeço Software Carpentry pelo uso desses dados. (http://swcarpentry.github.io/)

Imagine que você trabalha num laboratório farmacêutico que está desenvolvendo um novo tratamento para artrite. Você precisa avaliar os resultados de uma teste deste tratamento para ver se cumpriu os objetivos que a empresa teve para ele. Você recebe o arquivo `inflamação.csv`, um arquivo de Excel gravado no formato csv (*comma separated values*). Você precisa colocar este arquivo no seu *working directory* e carregar os dados na memoria onde R pode operar neles. 

### Passo 1 --- Criar Um Projeto

Primeiro, criaremos um projeto em RStudio onde vamos colocar a análise de artrite. 

Nós trabalharemos neste projeto (e pasta) enquanto trabalhamos com a artrite. No sistema operacional podemos colocar o arquivo `inflamação.csv` na pasta de seu projeto `artrite`.

### Passo 2 --- Carregar o Tidyverse

Neste exercício e em todo o curso, nós vamos usar muitas funções do Tidyverse. Estas funções existem em vários pacotes. O pacote `tidyverse` é uma coleção dessas outras pacotes e vai carregar eles. Apesar que existem outros pacotes no Tidyverse, aqueles carregados pelo `tidyverse` são os mais importantes e eles permitem que nós podemos ler arquivos, manipular dados, fazer análises e visualizar gráficos. Antes de desenhar gráficos, nós vamos carregar um outro pacote `ggpubr` que simplifica os comandos gráficos utilizando a tecnologia `ggplot`, o componente centrais dos gráficos de Tidyverse.

Para carregar pacotes que já temos instalados no computador, usamos a função `library()` com o nome do pacote como argumento. Entretanto, para ver o efeito de carregar o Tidyverse, vamos olhar na diferença entre o estado da memoria antes e depois do Tidyverse. Para isso, usamos a função `sessionInfo()` para mostra o que está carregado. Primeiro, aqui é como sua memoria quando você inicia R.

```{r tidyv, echo = TRUE, eval = FALSE}
sessionInfo() ## Comando para mostrar o estado do sistema R neste momento
```

```{r siantes, echo = FALSE, fig.align='center', fig.cap = "Pacotes Antes Tidyverse"}
knitr::include_graphics(glue::glue(gr, '/session_bare.png'))
```

Só têm os sete pacotes básicos que R carregar quando incia. Agora vamos carregar o Tidyverse.

```{r tv2, echo = TRUE}
library(tidyverse)
```

```{r tv3, echo = TRUE, eval = FALSE}
sessionInfo()
```


```{r tidyverse_load, echo = FALSE, fig.align='center', fig.cap = "Tidyverse Básico"}
knitr::include_graphics(glue::glue(gr, '/session_tidyv.png'))
```

Agora, a memoria é bem diferente. Temos os nove pacotes carregados como *other attached packages* e 15 pacotes novos carregados em um *namespace* (conceito mais avançado que nosso curso) que são disponíveis para uso pelos pacotes de tidyverse.

### Passo 3 --- Download os Dados de GitHub

Os dados atualmente existem no GitHub. No capitulo 1, aprendemos como fazer o download dos arquivos do GitHub. Siga o mesmo processo em seu sistema operacional e com seu browser para pôr `inflamacao.csv` na pasta do seu projeto `artrite`. 

Para ajudar, aqui é um resumo dos passos:

- aponte a browser para o repo do curso: https://github.com/jameshunterbr/MAD-Biomedicina-2019
- clique no nome do arquivo: `inflamacao.csv`
- clique no botão "Raw"
- salvar a página na pasta do projeto. [^5]

[^5]: Se o browser quer que você usa o sufixo "txt" para seu arquivo, precisa insistir no uso de "csv". Um arquivo "csv" é um tipo de arquivo de texto simples, mas outros programas como Excel só querem ver o sufixo "csv".

### Passo 4 --- Carregar os Dados na Memoria de R

R precisa ter todos os dados em que vai operar na memoria ativa do computador. Não trabalha nas cópias gravadas dos arquivos para fazer operações. Outras linguagens como SQL e C podem operar em dados gravados, mas R não. Entretanto, este não e um limite em qualquer sentido prática. Nos laptops modernos, o espaço de memoria fica suficiente grande para suportar quase qualquer base de dados, mesmo se tivesse múltiplas gigabytes de dados.

Para carregar, nós vamos usar a função `read_csv()` que vai pegar o arquivo e criar um objeto na memoria do R. 

```{r load_dados, message = FALSE}
dados <- read_csv(file = "inflamacao.csv", col_names = FALSE)
```

```{r env_dados, echo = FALSE, fig.align='center', fig.cap = "Environment com dados"}
knitr::include_graphics(glue::glue(gr, '/environment_dados.png'))
```

A função `read_csv()` vem do pacote `readr`. Ela tenta automatizar tanto quanto é possível a importação dos dados. Até, ela analisa os dados para decidir qual é o tipo de dados que o conjunto tem: caráter, número inteiro, número decimal, lógico, etc. Também usa a primeira linha como o nome das variáveis (colunas da planilha). Neste caso, as colunas só têm dados, não nomes na primeira linha. Então, temos que avisar `read_csv()` disso. Assim, usamos o argumento `colnames = FALSE` porque o padrão é `colnames = TRUE`, como a tela de *Help* para `read_csv` mostra.
 
```{r help_read_csv, echo = FALSE, fig.align='center', fig.cap = "read_csv Help"}
knitr::include_graphics(glue::glue(gr, '/read_csv_help.png'))
``` 

### Passo 5 --- Qual É o Tipo do Conjunto dos Dados?

Para saber os tipos de análises que podemos fazer no `dados`, precisamos determinar o que temos. Sabemos que temos 40 variáveis que são os dias em que a avaliação foi feita. Primeiro nível de informação é sobre o tipo de dados que temos. Para isso, usamos a função `class()`.

```{r class_db}
class(dados)
```

Este quatro descritores indicam que este é um *tibble*, um tipo avançado de `data.frame`. Este é o tipo básico de um conjunto de dados quadrado, com variáveis nas colunas e observações na fileiras. As capacidades adicionais têm a maior significância para as operações internas do R e das funções do Tidyverse, mas pode ser muito mais rápido para conjuntos grandes de dados. 

Existem duas outras funções que mostram mais detalhe sobre o conjunto. `str()` vai mostrar para todo o conjunto a classe (tipo) da variável os primeiros valores dela. `glimpse()` faz a mesma coisa mas com as linhas e colunas trocados. `glimpse()` oferece uma visão mais completa que `str()`. Por causa do tamanho do output in nosso caso com 40 variáveis, vou limitar ela para cinco variáveis usando uma técnica que aprenderemos abaixo.

```{r}
str(dados[, 1:5])
glimpse(dados[, 1:5])
```


Também, podemos examinar o tamanho do conjunto usando a função `dim()` (dimensões). Esta retorna para você o número e linhas e colunas nos dados. 

```{r dim_dados}
dim(dados)
```

As variáveis são do mesmo tipo. Por isso, podemos olhar no primeiro cinco para ver suficiente detalhe sobre os dados. 

### Passo 6 --- Subconjuntos (*Subsets*) de `dados`

Nós queremos focar nas primeiras cinco variáveis porque mais que isso é simplesmente repetitivo e desnecessária por enquanto. Têm duas maneiras que podemos fazer este foco, um que vem de R básico e o outro que introduza a gente para `dplyr` e a manipulação dos dados no Tidyverse.

*Subconjuntos em R Básico* -- Índices

Podemos referir a um dado individual colocando um índice dentro de colchetes (`[]`), com a fileira primeiro e a coluna depois. Por exemplo, para o primeiro dado em `dados`, podemos dizer `dados[1,1]`. Se nós queremos as avaliações para os primeiros cinco dias (colunas) para paciente 1, podemos dizer `dados[1, 1:5]`. Os dois-pontos diz "todos os valores entre valor 1 e valor 5". Se nós queremos as avaliações dos cinco primeiro pacientes (fileiras) no primeiro dia (coluna), podemos dizer `dados[1:5, 1]`. Se nós queremos ver todos as colunas ou todas as fileiras, simplesmente precisa deixar essa parte do índice em branco. Mas precisa incluir sempre a virgula ou R não vai saber em qual dimensão você refere. Por exemplo, se queremos ver o valor para todos os dias de paciente 50, podemos dizer `dados[50, ]`.  O próximo bloco de código mostra todas esses opções.

```{r subset1}
dados[1,1]
dados[1, 1:5] # 1º paciente, 1º cinco dias
dados[1:5, 1] # 1º 5 pacientes, 1º dia
dados[50, ] # paciente 50, todos os dias
```

*Subconjuntos no Tidyverse* -- `dplyr`

Este código parece razoável, mas não muito claro. Não segue as recomendações sobre nomes de variáveis por exemplo. É típico das linguagens de computação. Com o Tidyverse, podemos fazer este aparecer mais como um idioma normal. Nós vamos usar umas novas funções para fazer os subconjuntos que queremos. 

Primeiro desses funções permite que combinamos operações das funções diferentes na mesma expressão. Este símbolo está chamada o "pipe" e está escrito assim: `%>%`. Este conceito é muito comum em linguagens de computação,  especialmente do sistema UNIX, apesar que está expressa por vários símbolos. Em R, o pipe quer dizer "aceite o resultado da operação no lado esquerdo e aplique a função no lado direto ao este resultado". Com o uso do pipe, nós não precisamos repetir o nome do objeto do lado esquerdo da operação quando você especifica a função no lado direto. 

O termo *pipe* não vem do sentido de tubo, mas da palavra "cachimbo" vindo de arte surrealista, especificamente do quadro do pintor belga René Magritte, "Ceci n'est pas une pipe". Por quê? Porque veio originalmente do pacote `magritte`, mas agora está incorporado no `dplyr`, o pacote principal do `tidyverse` para a manipulação dos dados.

```{r pipe, echo = FALSE, fig.align='center', fig.cap = ""}
knitr::include_graphics(glue::glue(gr, '/ceci_nest_pas_pipe.jpg'))
```

Para nosso exemplo, o código vai parecer complicado em comparação ao código acima, mas ele ilustra funções importantes que ajudaria você em projetos mais complicados. As funções que vamos usar são os seguintes:

- `slice()` -- seleciona as linhas segundo a posição delas

- `select()` -- seleciona as colunas por nome

```{r tidy_ex}
# equivalente a dados[1,1]

dados %>% 
  slice(1) %>% 
  select(X1)

# equivalente a dados[1, 1:5]

dados %>% 
  slice(1) %>% 
  select(X1:X5)

# equivalente a dados[1:5, 1]

dados %>% 
  slice(1:5) %>% 
  select(X1)

# equivalente a dados[50, ]
dados %>% 
  slice(50)
```

Uma vantagem da gramatica do Tidyverse com o pipe é que facilita a explicação da operação do comando. Por exemplo, a última expressão pode ser lido como: "começa com o conjunto `dados`; depois utiliza as primeiras 5 fileiras e depois seleciona a primeira variável". Quando você tem expressões complicadas, que usam muitos verbos (palavra que o Tidyverse usa para refere às ações como `slice` ou `select`), este habilidade de ler a expressão em quase-português faz a programação mais compreensível.

Você pode ver que as variáveis têm nomes estranhos, `X1`, etc. Para nossos fins, este não é horrível porque refere corretamente ao número de dia, 1 até 40. Entretanto, podemos fazer melhor. No próximo bloco, nós vamos dar nomes mais claros às variáveis introduzindo o conceito de um "*loop*" ou uma série repetitiva das ações que podemos executar repetidamente.

### Novos Nomes para as Variáveis --- Loops

Nomes mais claros para as variáveis ajudaria nosso entendimento do conjunto `dados` e faria a apresentação dos dados mais profissional. Existem várias técnicas que podemos usar para fazer, mas é um bom momento para ver um loop, um dos conceitos mais básicos da programação. Nós vamos criar um loop de tipo "*for*", que vai repetir comandos um certo número de vezes. O loop tem o formato: 

`for`(expressão que define o número de repetições) {
  código para executar dentro do loop
} 

Queremos que o loop considerar todas as variáveis, o número de que podemos determinar automaticamente com a função `seq_along()`. Esta função define uma sequência que começa com 1 e continua até o número das variáveis. Dentro do loop nós vamos criar um vetor com 40 cadeias de caráteres composto da palavra "dia" mais um número para o dia. Para fazer isso, usamos a função `paste0()` que concatena os argumentos da função e produz uma cadeia de caráteres. O número resultará do contador das iterações do loop, `i`. `paste0` difere da função `paste()` só pelo fato que `paste()` insere um espaço entre os elementos da função mas `paste0()` não, como implica o nome da função. Quando o loop completa as 40 iterações, ele para e passa controle para a próxima expressão no programa. Nesta linha, a função `col_names()` vai transferir o vetor dos nomes para `dados` como novos nomes das variáveis. [^6]

[^6] O Tidyverse tem uma função equivalente, `glue()`, que vem do pacote homônimo. O funcionamento é em grande parte o mesmo. Pessoalmente, quando trabalho só com concatenação de textos, uso `paste()` e quando estou combinando o resultado dos cálculos com texto, uso `glue()`. Mas, aqui, para consistência, ficarei com `paste()` e `paste0()`. 

Antes de começar a operação do loop, devemos instruir R onde colocar os nomes que o loop está compondo. Vou criar uma variável `nome` que será um vetor vazio. Durante a operação do loop, ele vai acrescentar os novos valores usando a função `c()`. 

```{r loop_nomes}
nome <- vector(mode = "character") 
for (i in seq_along(dados)) {
  nome <- c(nome, paste0("dia", i))
}
colnames(dados) <- nome
str(dados[, 1:5])
```


Deixa-me explicar todos as linhas e os elementos deste código:

- `nome <-` a linha que especifica o vetor para conter os resultados do loop 

- `for` a definição do loop; a linha termina com a chave que inicia o bloco de código que o loop vai executar

- `(i in seq_along(dados))` instrução para substituir a variável `i` no bloco de código com os números definidos pela expressão `seq_along`

- `seq_along(dados)` - a sequência a ser definido que representa todos as variáveis conforme o cálculo abaixo

```{r calc_seq}
seq_along(dados)
```

- `nome <- c(nome, paste0("dia", i))` Concatenar a palavra "dia" com o valor de `i` (e.g. "dia1") e acrescentar este valor ao vetor `nome` 

- `}` indicação do fim do bloco de código; quando encontra isso, o loop volta ao início e processa o próximo valor de `i`

- `colnames(dados) <- nome` Quando termina o loop, dar novos nomes às colunas (variáveis) de `dados`

- `str(dados[, 1:5])` Mostra a nova estrutura das primeira cinco colunas do tibble `dados` para confirmar que fizemos a operação de dar novos nomes com êxito.

## Análise de Dados de Inflamação

Vamos fazer um resumo dos dados e olhar em alguns gráficos para poder entender os dados melhor e preparar para tirar conclusões sobre o novo tratamento. Só para esta apresentação dos dados e das funções, vamos limitar os resumos aos dias 20 até dia 25. Mas os gráficos incluirá todos os dias (variáveis). Uma função básica para resumir dados é `summary()` que relata os valores seguintes:

- valor mínimo da variável (`min`)
- 1º quartil (25º percentil)
- mediana (50º percentil) (`median`)
- 3º quartil (75º percentil)
- valor máximo (`max`)

Também, existem muito outros resumos dos dados em R básico e nos pacotes que já fez o download. Durante o curso, vai encontrar vários desses pacotes e funções. O que `summary()` não relata que é muito importante é uma medida de variabilidade. Normalmente, usamos o desvio padrão para medir isso. Precisamos calcular isso separadamente de `summary()` usando a função `sd()` (*standard deviation*). Vamos calcular um resumo dos dados depois de fazer o subset que queremos.

Mas, para fazer este cálculo de `sd()`, podemos usar um loop, mas tem outra maneira de conseguir a mesma coisa. O objetivo é calcular uma função para um número de variáveis em uma única operação. A família das funções `map()` calcula uma função (neste caso `sd()`) para todas as variáveis de nosso subset das variáveis. A função é muito simples e flexível. `map()` normalmente produz um tipo de dados chamado uma lista. Nós não queremos isso; queremos um vetor dos desvios padrão. Para conseguir isso, nós usamos o variante `map_dbl()` que produz um vetor dos números reais. Estamos colocando isso numa expressão *tidy* em que o pipe entrega o subset (`sub_dados`) para a função `map_dbl()`, a expressão só precisa o nome de função que queremos calcular (`sd`) sem os parênteses. 

```{r}
sub_dados <- dados %>% 
  select(dia20:dia25)
glimpse(sub_dados)
summary(sub_dados)
sub_dados %>% map_dbl(sd)
```


## Gráficos do Conjunto dos Dados

Com um conjunto de dados intensivo, olhando nas tabelas e resumos não ajuda muito no entendimento do que dizem os dados. Gráficos comunicam melhor. Primeiro, queremos ver a tendência da inflamação no decorrer do estudo. Cresceu, diminuiu, quando, por quanto? Para descobrir isso, podemos calcular a média para cada dia e mostrar isso num gráfico de dispersão (*scatter plot*). Para este gráfico, nós vamos ficar com o plotagem simples de base R. Apesar isso, o gráfico seria o resultado de um expressão *tidy* que calcula as médias dos dias e entregam eles para a função `plot()`. Os argumentos incluídos aqui para a plotagem tem a ver com a apresentação, como títulos (`main`, `xlab`, `ylab`) e estilo de caráter (`pch`).

Anote também que usamos a função `map_dbl()` de novo para calcular as médias e entregar esses valores para comando gráfico. 

```{r graf_scat, fig.height = 4, fig.width = 5, fig.cap = "Gráfico de Dispersão", message = FALSE}

dados %>% 
  map_dbl(mean) %>% 
  plot(type = "p", pch = 19, 
       main = "Inflamação por Dia\ncom Novo Tratamento",
       xlab = "Dia",
       ylab = "Grau de Inflamação") 
```

## Whew! Final da Introdução

Em pouco tempo, você já fez bastante R. Vale a pena tentar os blocos de código em casa e talvez ler a apostila mais de uma vez. Ao final do curso, este documento seria muito maior, com minhas notas para todas as aulas gravadas aqui também. Vai ser um pequeno livro sobre R. 

Você olhou em cálculos simples e um conjunto de dados mais avançado. Você viu várias funções. Quando estamos juntos, nós vamos aplicar estas técnicas e muitas outras para problemas relacionados à biomedicina. Se você tem alguns assuntos que quer que eu cobra nas aulas, por favor entre em contato. Estou sempre aberto às sugestões.


# Importação dos Dados

Os conceitos que se desenvolverem aqui são os que são necessários para entendimento do uso das ferramentas de programação como R para resolver problemas práticas da ciência ou dos negócios. Já vimos uma introdução aos alguns desses conceitos no Capítulos 4 e 6. Algumas coisas vão repetir o que você já viu nos capítulos anteriores, mas numa forma mais organizada.

## Fluxo de Trabalho de Análises em R

Qualquer projeto que precisa as ferramentas da ciência de dados tem uma forma e fluxo de trabalho parecida. O diagrama seguinte mostra este processo: [^7]

```{r process_w, echo = FALSE, fig.align='center', fig.cap = "Processo de Programação com R"}
knitr::include_graphics(glue::glue(gr, '/wickham_process.png'))
```

[^7]: Wickham, Hadley & Grolemund, Garrett, **R for Data Science** (O'Reilly, Sebastopol, CA, January 2017).

O primeiro passo em qualquer análise em R é para **importar** os dados que vai analisar. O fonte mais popular nestes dias atuais é Microsoft Excel. Aqui nós vamos aprender como importar arquivos nos formatos `.csv` ou `xlsx` (ou seu primo mais antigo `.xls`) usando funções do Tidyverse.

Com os dados na memória de R como objeto, o próximo passo é para **arrumar** eles. Esta fase do trabalho inclui a descoberta dos erros de recordação, decidir o que fazer com variáveis que têm dados faltando (dados `NA`). Você precisa também ver se as variáveis têm valores bem fora dos valores esperados (*outliers*) e também decidir como tratar eles. Finalmente, aqui você pode acertar que os dados ficam *tidy*, ou seja, num formato consistente em que toda coluna é uma variável, toda linha uma observação e que cada conjunto de dados (`data.frame` ou `tibble`) só contem um tipo de dados. Essa consistência deixa você focar na análise e as questões que você quer responder sem precisar fazer uma nova limpeza ou arrumação. Surpreendentemente, esta fase de arrumar dados ocupa mais tempo que o tempo necessário para fazer as análises; leva até 70% do tempo inteiro que vai investir no projeto.

Uma vez que esses primeiros passos são completos, pode estudar as questões que motivaram o projeto no primeiro lugar. Nesta fase, o seu trabalho é cíclico. Você vai preparar um conjunto de dados menor que põe o foco nas observações que ajudam você responder à questão de interesse. As vezes, vai precisar transformar a escala ou unidade dos dados para facilitar a análise. Todo este processo de fazer um subconjunto do dados está chamada da fase de **transformação**. 

Com os dados transformados, você pode explorar eles para entender a distribuição dos valores e a relação entre as variáveis. Nesta fase de **visualização**, você usa gráficos e tabelas para ver as possíveis abordagens dos modelos. Quando tem uma boa ideia da estrutura dos dados, pode experimentar um **modelo**. Quando você examina o resultados dos modelos, pode perceber que existem métodos de análise que produzirem respostas mais exatas às suas perguntas. Também pode ver se os resultados cumprem as premissas do modelo usado. Todos os modelos têm premissas que os dados devem seguir. Senão, precisa usar um outro tipo de modelo que permite o uso do conjunto dos dados que você está empregando.

É assim que essas fases de *transformação-visualização-modelagem* formam um ciclo. Você explora os dados e conduza as análises repetitivamente até que você consegue responder para sua pergunta. 

Ao final, você deve fazer uma **reportagem** das análises. Uma análise sem um relatório é como o Koan zen que pergunta qual é o som de uma mão batendo palmas. Talvez produz grande iluminação pessoal mas não para os outros.

## Importar Dados para R

### `read_csv()` --- Arquivos .csv 

Já apresentei o uso de `readr::read_csv()` (o nome de um pacote seguido por 2 dois pontos e o nome de uma função é usado em R para especificar qual versão desse nome você quer usar ou, como neste caso, para enfatizar de qual pacote a função vem) em relação dos dados de inflamação. Vamos aplicar esta função para um caso de marcadores de infecção pelo vírus HIV-1, carga viral (cv) e nível dos células T-CD4+.

```{r cv_cd4_excel, echo = FALSE, fig.align='center', fig.cap = "Excel - Dados HIV.csv"}
gr <- here::here("graficos")
knitr::include_graphics(glue::glue(gr, '/excel_hiv.png'))
```

Porque o padrão para o argumento `col_names` é `TRUE`, neste caso, podemos deixar a função importar as palavras na primeira linha como os nomes de variáveis. Se você não quer usar os nomes do Excel, pode mudar o argumento para `FALSE`, como fizemos no último capitulo. Também, `readr` tentará interpretar quais são as classes dos valores nas colunas, utilizando os primeiras 100 linhas para determinar se são caráteres, números, datas, ou valores lógicos. Você pode controlar os tipos de colunas com o argumento `col_types`. Neste caso, se quisemos, podemos especificar as colunas como `col_types = c(c,c,n,c)` (caractere, caractere, número, caractere) como esta figura mostra.

```{r col_types_help, echo = FALSE, fig.align='center', fig.cap = "Tipos de Coluna"}
knitr::include_graphics(glue::glue(gr, '/col_types_help.png'))
```

Para importar o arquivo dos pesos e alturas, podemos confiar que `read_csv()` vai reconhecer corretamente os tipos das colunas e que queremos os nomes na primeira linha como nomes das variáveis na base de dados. Podemos então usar uma forma simples do comando. Você pode ver que o tibble que resulta tem as classes (tipos) de variáveis corretos.

**VSS** *Se você tem o seu arquivo `.csv` com números do estilo brasileiro (com uma vírgula como o separador entre a mantissa e as casas decimais), você precisa usar a versão da função `read_csv2()`*. Esta versão da função separa os valores com um ponto e vírgula e reserva a vírgula usado sozinho para separador decimal.

```{r imp_hiv, echo = TRUE}
wd <- here::here()
cv_cd4 <- readr::read_csv(glue::glue(wd, '/dados_cv_cd4.csv'))
str(cv_cd4)
```

Quando discutimos a limpeza dos dados, nós vamos transformar a variável `Date` para uma variável do tipo `Date` para que possamos utilizar em cálculos das datas. `read_csv()` somente importa como um *string* (cadeia de caracteres) se você não especifica uma sequência dos tipos de coluna porque existem tantos maneiras para retratar datas no mundo inteiro que R não tenta de adivinhar qual é o formato usado.

### Planilhas de Excel

O sistema `tidyverse` inclui um pacote, `readxl` que facilita importar os dados diretamente de uma planilha do Excel. Entretanto, ele não está carregado pelo comando `library(tidyverse)` e precisa ser carregado individualmente. `readxl` pode importar uma planilha do tipo moderno de `.xlsx` ou do tipo antigo `.xls`. O comando `read_excel()` tenta adivinhar qual é o tipo de arquivo que você abre. Se tiver problemas com o arquivo, você pode usar ou `read_xlsx` ou `read_xls` diretamente para abrir aquele tipo de arquivo. 

Para demonstrar esta função, eu vou usar um arquivo derivado de um outro projeto verdadeiro de pesquisa em que estou envolvido sobre a doença HIV. A planilha mostra alguns dados sobre os pacientes e sobre os resultados dos exames que eles fizeram ao início do estudo. Esta planilha, `pac_demo.xlsx` tem duas folhas. A primeira, `pac_demo`, contem os dados. A segunda folha, `data_dic` tem a dicionário dos dados, ou seja, uma lista dos nomes das variáveis, os seus tipos, e uma explicação textural do conteúdo. 

```{r data_dic, echo = FALSE, fig.align='center', fig.cap = "Diccionário dos Dados"}
knitr::include_graphics(glue::glue(gr, '/excel_data_dic.png'))
```

**VSS** *É sempre uma boa praxe criar uma dicionário dos dados para seu trabalho.* Pode ser no formato em que você grava os dados inicialmente (e.g., Excel), em R ou até num caderno. Vale muito a pena para ajudar você e outros entender e reproduzir os seus resultados.

A função `read_excel()` funciona muito semelhante a função `read_csv`. Você especifica o arquivo para ser importado, o nome da folha (diferentemente de uma arquivo `.csv`, que não tem folhas), uma cadeia de caracteres para os tipos das colunas, além das outras opções que pode consultar na tela de `Help`.

```{r read_excel_file, echo = TRUE}
pac_data <- readxl::read_excel(glue::glue(wd, '/pac_demo.xlsx'), 
                               sheet = "pac_demo")
tibble::glimpse(pac_data)
```

No passado com R e até hoje com outras linguagens, foi considerado necessário salvar uma planilha em `.csv` antes de importar. Com o pacote `readxl`, este passo não é mais necessário. Pode importar diretamente da planilha original.

## Nomes dos Objetos em R

Nomes dos objetos (variáveis, funções, etc.) em R devem começar com uma letra e contem só letras, números, `_` (caractere de sublinhado), e `.` (ponto final). 

Além disso, nomes devem ser descritivos para que você lembra o que você está fazendo e para outros o conhecem facilmente. Assim, você provavelmente vai querer combinar mais que uma palavra. Para fazer isso, existem alternativas que vários programadores usam:

1. combine_palavras_assim (*snake case*)
2. useMaiusculosMinusculos (*camel case*)
3. usar.pontos.entre.palavras

Minha preferência é para #1, *snake case* porque não precisa mexer com as letras maiúsculos e inclui um pouco de espaço entre as palavras. Experiência mostra que qualquer opção você escolhe, seja consistente no uso dele.

Também, R e todas as outras linguagens de programação são muitos bravas sobre a ortografia das palavras. Se você não escreve o nome de um objeto exatamente na forma que você o designou originalmente, R não vai o reconhecer e vai retornar um erro.  

```{r nomes_erros, echo = TRUE}
r_designacao <- 26 * 37
# agora quero ver o valor
```

```{r spell, echo = FALSE, fig.align='center', fig.cap = "Erros de atribuição"}
knitr::include_graphics(glue::glue(gr, '/spelling_erro.png'))
```

Essas duas tentativas não deram certas. A primeira substituiu um ponto para o sublinhado e o segundo corrigiu este erro mas usou um "D" maiúsculo. Entretanto, se teclamos o nome certo ...

```{r no_erro}
r_designacao
# Finalmente, o valor

```

A diferença de só 1 caractere é suficiente para confundir R e produz o erro. Também, R distingue entre letras minusculas e letras maiúsculas. **VSS** *Prestem atenção nos detalhes dos nomes dos objetos.* 

### Assistência -- RStudio

Na luta para lembrar e grafar os nomes dos objetos corretamente, RStudio pode ajudar você com 2 atalhos. Primeiro, se você escreve os primeiros caráteres de um nome e toca na tecla <TAB>, RStudio vai dar uma lista dos objetos (variáveis, data frames, tibbles e funções) que começam com este sequência dos caráteres. A figura seguinte mostra esta ajuda. Selecione o nome que você quer e toca no <TAB> de novo. RStudio vai completar o nome.

```{r name_help, echo = FALSE, fig.align='center', fig.cap = "<TAB> Ajuda com Nomes"}
knitr::include_graphics(glue::glue(gr, '/name_choice.png'))
```

Segundo, se você tecla uma linha de código complicado e fazer um erro, mas não quer teclar toda a linha de novo, RStudio pode ajudar você. O software lembra todas as linhas de código que você já escreveu. Se você escreve só os primeiros caráteres da linha e toca nas teclas <CMD/CTRL> + <SETA-PARA-CIMA> e RStudio mostrará as últimas linhas de código que usam estes caráteres ao início. No exemplo seguinte, uma linha de código de um projeto de pesquisa meu, teclei o nome de um objeto como `trpl_new` e R retornou um erro. Eu quis `prpl_new`. Invés de escrever toda a linha de novo, posso tocar a combinação de <CMD/CTRL> + <SETA-PARA-CIMA> no Console (não na janela de programação), e a historia dos comandos aparecerá. Selecione a linha que você quer inserir, faça sua correção e executar. Se a linha de código que você quer repetir (para corrigir) é a última, existe uma versão simplificada deste truque: só toque na tecla de <SETA-PARA-CIMA> e a última linha vai aparacer no Console. Finalmente, você pode ver todas as linhas que você já executou, mesmo se eles vieram das sessões de trabalho anteriores na aba `History` da janela a cima para direta como a figura seguinte mostra. [^8] 

[^8]: É difícil de mostrar isso num documento. Criarei um vídeo no canal de YouTube para demonstrar como funciona este ajuda histórica.

```{r history, echo = FALSE, fig.align='center', fig.cap = "<TAB> Janela de History"}
knitr::include_graphics(glue::glue(gr, '/history.png'))
```

